#!/usr/bin/env ruby

#require "rubygems"
#require "bundler/setup"
#$LOAD_PATH.unshift File.join(File.dirname(__FILE__), '../lib')

require 'git-process/git_process_options'
require 'git-process/rebase_to_master'
require 'git-process/git_lib'


class ToMasterOptions
  include GitProc::GitProcessOptions


  def summary
    "Rebase against the integration branch, then pushes to it."
  end


  def description
    <<DESC
DESCRIPTION

This fetches the latest changes from the server, rebases against \
the integration branch, pushes to the integration branch, then does \
housecleaning.

If there is a problem, such as a merge conflict, this tries to \
resolve it automatically (including responding appropriately to
"rerere" merges). If it can not do so in an automated way, \
if tells you the steps involved for doing so manually.

"Housecleaning" includes such things as closing any \
Pull Request that may exist for the branch, removing the (now obsolete) \
local and remote feature branches, and then "parking" on the \
special "_parking_" branch.

Work is not expected to be done on the "_parking_" branch, but any that is \
done is brought over to a newly created feature branch when you do \
"git new-fb".

It's assumed that you *never* do any work directly on "master": \
everything is done on a feature branch.  In addition to being a much \
safer and more flexible way of working in general, it is also a \
requirement to take advantage of Pull Request functionality.

By default the first server name reported by 'git remote' is used as the \
server/remote name. Since most projects only have a single remote (i.e., \
"origin") this works most of the time. But if you have multiple remotes and \
want to explicitly set it, use the 'gitProcess.remoteName' configuration option.

If a number is given, or a number with a server preceding it (e.g., \
"origin/23"), then this assumes that the number refers to an existing pull \
request identified by that number. In that case, the branch associated with \
the HEAD of the pull request is checked out before doing the rest of the \
"to-master".

EXAMPLE WITHOUT PULL REQUEST

Assuming that the current branch is called "interesting_changes" and the \
integration branch on the server is "master", typing "git to-master" will do \
roughly the following for you:
  $ git fetch -p
  $ git rebase origin/master
  $ git push origin interesting_changes:master
  # close pull request if one exists
  $ git checkout -b _parking_ origin/master
  $ git branch -d interesting_changes
  $ git push origin --delete interesting_changes

If you use the --interactive option, then it does an interactive rebase before the first "push".

If you use the --keep option, then the process stops after the first "push".


EXAMPLE WITH PULL REQUEST

Assuming that the pull request number is 493, its branch name is "interesting_changes" \
and the integration branch on the server is "master", typing "git to-master 493" will \
do roughly the following for you:
  $ git fetch -p
  # looks up the information for pull-request 493
  $ git checkout -b interesting_changes origin/interesting_changes
  $ git rebase origin/master
  $ git push origin interesting_changes:master
  # close pull request
  $ git checkout -b _parking_ origin/master
  $ git branch -d interesting_changes
  $ git push origin --delete interesting_changes

If you would like the review the changes locally first, use "git pull-request 493"
instead.

NOTES

* If you want to use a different integration branch other than "master",
  set the "gitProcess.integrationBranch" configuration value. (e.g.,
  "git config gitProcess.integrationBranch my-integ-branch")

DESC
  end

  def usage(filename)
    "Usage: #{filename} [ options ] [server/pull_request_number | pull_request_number]"
  end


  def extend_opts(parser)
    parser.opt :keep, "Don't do any \"cleanup.\" It keeps the current local "+
        "and remote branches, and does not close any "+
        "outstanding pull requests.", :short => :k, :default => false
    parser.opt :interactive, "Do an interactive rebase before pushing to the server.", :short => :i, :default => false
  end


  def post_parse(opts, argv)
    arg = argv.shift
    if /^\d+$/ =~ arg
      opts[:prNumber] = arg
    elsif /^(.*)\/(\d+)$/ =~ arg
      m = /^(.*)\/(\d+)$/.match(arg)
      opts[:server] = m[1]
      opts[:prNumber] = m[2]
    else
      # "normal" to-master
    end
  end

end

opts = ToMasterOptions.new.parse_cli(File.basename(__FILE__), ARGV)
GitProc::RebaseToMaster.new(GitProc::GitLib.new('.', opts), opts).run
